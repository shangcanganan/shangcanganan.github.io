<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[linux安装Tomcat和jdk]]></title>
    <url>%2F2018%2F09%2F10%2Flinux%E5%AE%89%E8%A3%85Tomcat%E5%92%8Cjdk%2F</url>
    <content type="text"><![CDATA[linux安装Tomcat和jdk步骤 下载tomcat和jdk。 把下载好的压缩包通过xftp5上传到linux服务器。 通过命令解压 1tar -zxvf 文件名 然后将解压的jdk文件夹移动到usr/local文件夹下 1mv + 文件名 + /usr/local 解压Tomcat,将Tomcat文件夹重新命名 1mv + 文件名 + 新名称 修改/etc/profile文件 1vim /etc/profile 在文件中最后加入环境配置 123export JAVA_HOME=/usr/local/jdk1.8.0_11export PATH=$JAVA_HOME/bin:$PATHexport CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar 编辑tomcat文件下的server.xml文件 1vim tomcat/conf/server.xml 将其中的端口改成80 在Tomcat的bin文件夹下启动Tomcat 1./startup.sh (注释： ./ 代表当前目录)]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之代理模式]]></title>
    <url>%2F2018%2F09%2F03%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[设计模式之代理模式概念代理模式给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用。通俗的来讲代理模式就是我们生活中常见的中介。 为什么要用代理模式？ 中介隔离作用：在某些情况下，一个客户类不想或者不能直接引用一个委托对象，而代理类对象可以在客户类和委托对象之间起到中介的作用，其特征是代理类和委托类实现相同的接口。 开闭原则，增加功能：代理类除了是客户类和委托类的中介之外，我们还可以通过给代理类增加额外的功能来扩展委托类的功能，这样做我们只需要修改代理类而不需要再修改委托类，符合代码设计的开闭原则。代理类主要负责为委托类预处理消息、过滤消息、把消息转发给委托类，以及事后对返回结果的处理等。代理类本身并不真正实现服务，而是同过调用委托类的相关方法，来提供特定的服务。真正的业务功能还是由委托类来实现，但是可以在业务功能执行的前后加入一些公共的服务。例如我们想给项目加入缓存、日志这些功能，我们就可以使用代理类来完成，而没必要打开已经封装好的委托类。 实现1234567891011121314151617181920212223242526272829303132333435363738394041424344public class NetworkTest &#123; public static void main(String[] args) &#123; Server server = new Server(); ProxyServer proxyServer = new ProxyServer(server); proxyServer.browse(); /**输出 * 访问之前的检验 * 真实的服务器访问网络 */ &#125;&#125;interface Network&#123; public void browse();&#125;//被代理类class Server implements Network&#123; public void browse() &#123; System.out.println("真实的服务器访问网络"); &#125;&#125;//代理类class ProxyServer implements Network&#123; private Network network; public ProxyServer(Network network)&#123; this.network = network; &#125; public void check()&#123; System.out.println("访问之前的检验"); &#125; public void browse() &#123; check(); network.browse(); &#125;&#125;]]></content>
      <categories>
        <category>java设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之单例模式]]></title>
    <url>%2F2018%2F09%2F02%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[单例模式饿汉式12345678910111213141516171819202122public class SingletonTest &#123; public static void main(String[] args) &#123; St instance = St.getInstance(); St in = St.getInstance(); System.out.println(instance == in );//true &#125;&#125;class St&#123; //构造函数私有化 private St()&#123; &#125; private static St St = new St(); public static St getInstance()&#123; return St; &#125;&#125; 懒汉式12345678910111213141516171819202122232425public class SingletonTest2 &#123; public static void main(String[] args) &#123; St instance = St.getInstance(); St in = St.getInstance(); System.out.println(instance == in ); &#125;&#125;class St2&#123; //构造函数私有化 private St2()&#123; &#125; private static St2 St2 = null; public static St2 getInstance()&#123; if(St2==null)&#123; St2 = new St2(); &#125; return St2; &#125;&#125;]]></content>
      <categories>
        <category>java设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[idea配置]]></title>
    <url>%2F2018%2F08%2F01%2Fidea%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[idea配置进入设置界面： 目录结构如下： Appearance &amp; Behavior设置主题 这里默认提供了三套主题：IntelliJ，Darcula，Windows。这里可以根据自己的喜好进行选择。 设置窗体及菜单的字体及字体大小 如果想要更多的主题效果的话，可以到如下的网站下载：http://www.riaway.com/ 下载以后，导入主题：（方式一）file–&gt; import setttings–&gt;选中下载的主题 jar文件–&gt;一路确认–&gt;重启。重启以后，新主题会自动启用。如果没有启用，可以如下方式选择： 补充:通过插件(plugins)更换主题 Editor - General设置鼠标滚轮修改字体大小(可忽略) 我们可以勾选此设置后，增加 Ctrl +鼠标滚轮快捷键来控制代码字体大小显示 设置鼠标悬浮提示 设置自动导包功能 Add unambiguous imports on the fly：自动导入不明确的结构Optimize imports on the fly：自动帮我们优化导入的包 设置显示行号和方法间的分隔符 如上图红圈所示，可以勾选 Show line numbers：显示行数。我建议一般这个要勾选上。 如上图红圈所示，可以勾选 Show method separators ：显示方法分隔线。这种线有助于我们区分开方法，所以建议勾选上。 忽略大小写提示IntelliJ IDEA的代码提示和补充功能有一个特性：区分大小写。如上图标注所示，默认就是 First letter区分大小写的。区分大小写的情况是这样的：比如我们在 Java代码文件中输入 stringBuffer，IntelliJ IDEA默认是不会帮我们提示或是代码补充的，但是如果我们输入StringBuffer就可以进行代码提示和补充。如果想不区分大小写的话，改为 None选项即可。 设置取消单行显示 tabs的操作如上图标注所示，在打开很多文件的时候，IntelliJ IDEA默认是把所有打开的文件名 Tab单行显示的。但是我个人现在的习惯是使用多行，多行效率比单行高，因为单行会隐藏超过界面部分 Tab，这样找文件不方便。 Editor – Font设置默认的字体、字体大小、字体行间距 Editor – Color Scheme修改当前主题的字体、字体大小、字体行间距(可忽略)如果当前主题不希望使用默认字体、字体大小、字体行间距，还可以单独设置： 修改当前主题的控制台输出的字体及字体大小(可忽略) 修改代码中注释的字体颜色 Doc Comment – Text：修改文档注释的字体颜色Block comment：修改多行注释的字体颜色Line comment：修改当行注释的字体颜色 Editor – Code Style设置超过指定 import个数，改为* (可忽略) Editor – File and Code Templates修改类头的文档注释信息 常用的预设的变量，这里直接贴出官网给的：${PACKAGE_NAME} - the name of the target package where the new class or interface will be created.${PROJECT_NAME} - the name of the current project.${FILE_NAME} - the name of the PHP file that will be created.${NAME} - the name of the new file which you specify in the New File dialog box during the file creation.${USER} - the login name of the current user.${DATE} - the current system date.${TIME} - the current system time.${YEAR} - the current year.${MONTH} - the current month.${DAY} - the current day of the month.${HOUR} - the current hour.${MINUTE} - the current minute.${PRODUCT_NAME} - the name of the IDE in which the file will be created.${MONTH_NAME_SHORT} - the first 3 letters of the month name. Example: Jan, Feb, etc.${MONTH_NAME_FULL} - full name of a month. Example: January, February, etc. Editor – File Encodings设置项目文件编码 说明：Transparent native-to-ascii conversion主要用于转换 ascii，一般都要勾选，不然 Properties文件中的注释显示的都不会是中文 设置当前源文件的编码(可忽略) 对单独文件的编码修改还可以点击右下角的编码设置区。如果代码内容中包含中文，则会弹出如上的操作选择。其中： ①Reload表示使用新编码重新加载，新编码不会保存到文件中，重新打开此文件，旧编码是什么依旧还是什么。②Convert表示使用新编码进行转换，新编码会保存到文件中，重新打开此文件，新编码是什么则是什么。③含有中文的代码文件，Convert之后可能会使中文变成乱码，所以在转换成请做好备份，不然可能出现转换过程变成乱码，无法还原。 Build,Execution,Deployment设置自动编译构建就是以我们编写的 java代码、框架配置文件、国际化等其他资源文件、JSP页面和图片等资源作为“原材料”，去“生产”出一个可以运行的项目的过程。 Intellij Idea默认状态为不自动编译状态，Eclipse默认为自动编译：设置为省电模式 (可忽略)如上图所示， IntelliJ IDEA有一种叫做省电模式的状态，开启这种模式之后IntelliJ IDEA会关掉代码检查和代码提示等功能。所以一般也可认为这是一种阅读模式，如果你在开发过程中遇到突然代码文件不能进行检查和提示，可以来看看这里是否有开启该功能。 设置代码水平或垂直显示]]></content>
      <categories>
        <category>idea</category>
      </categories>
      <tags>
        <tag>idea</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法之冒泡排序]]></title>
    <url>%2F2018%2F08%2F01%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%8B%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[排序算法之冒泡排序实现方式 实现方式 冒泡排序 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 代码实现1234567891011121314151617181920public class MaoPaoSort &#123; public static void main(String[] args) &#123; int arr[] = &#123;1,6,3,21,8,9,3,63,2,6&#125;; maoPao(arr); System.out.println(Arrays.toString(arr)); &#125; public static void maoPao(int arr[])&#123; for (int i = 0; i &lt; arr.length-1; i++) &#123; for (int j =0;j&lt;arr.length-1-i;j++)&#123; if(arr[j]&gt;arr[j+1])&#123; int tmp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = tmp; &#125; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法之希尔排序]]></title>
    <url>%2F2018%2F08%2F01%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%8B%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[排序算法之希尔排序实现方式 代码实现12345678910111213141516171819202122public class ShellSort &#123; public static void main(String[] args) &#123; int arr[] = &#123;2,6,2,6,4,3,7,9,53,2,6,1,2,&#125;; shell(arr); System.out.println(Arrays.toString(arr)); &#125; public static void shell(int arr[])&#123; for(int i=arr.length/2;i&gt;0;i/=2)&#123; for(int j = i;j&lt;arr.length;j++)&#123; for(int x = j-i;x&gt;=0;x-=i)&#123; if(arr[x]&gt;arr[x+i])&#123; int tmp =arr[x]; arr[x] = arr[x+i]; arr[x+i] = tmp; &#125; &#125; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法之快速排序]]></title>
    <url>%2F2018%2F08%2F01%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[排序算法之快速排序实现方式 实现原理 快速排序 通过一趟排序将待排序记录分割成独立的两部分，其中一部分记录的关键字均比另一部分关键字小， 则分别对这两部分继续进行排序，直到整个序列有序。 代码实现1234567891011121314151617181920212223242526272829public class KuaiSuSort &#123; public static void main(String[] args) &#123; int array [] = &#123;5,2,4,3,1,9&#125;; kuaiSu(array,0,array.length-1); System.out.println(Arrays.toString(array)); &#125; public static void kuaiSu(int array[],int start ,int end)&#123; if(start&lt;end)&#123; int tmp = array[start]; int low = start; int high =end; while (low&lt;high)&#123; while (low&lt;high&amp;&amp;tmp&lt;=array[high])&#123; high--; &#125; array[low] =array[high]; while (low&lt;high&amp;&amp;tmp&gt;=array[low])&#123; low++; &#125; array[high] = array[low]; &#125; array[low] = tmp; kuaiSu(array,start,low); kuaiSu(array,low+1,end); &#125; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法之插入排序]]></title>
    <url>%2F2018%2F08%2F01%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%8B%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[排序算法之插入排序实现方式 代码实现123456789101112131415161718192021public class ChaRuSort &#123; public static void main(String[] args) &#123; int arrays[] =&#123;3,5,6,8,3,6,43,1,3,7,4,9&#125;; chaRu(arrays); System.out.println(Arrays.toString(arrays)); &#125; public static void chaRu(int arr[])&#123; for(int i =1;i&lt;arr.length;i++)&#123; if(arr[i]&lt;arr[i-1])&#123; int tmp = arr[i]; int j; for(j=i-1;j&gt;=0&amp;&amp;tmp&lt;arr[j];j--)&#123; arr[j+1] =arr[j]; &#125; arr[j+1] = tmp; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
</search>

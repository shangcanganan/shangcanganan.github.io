[{"title":"linux安装Tomcat和jdk","date":"2018-09-09T16:00:00.000Z","path":"2018/09/10/linux安装Tomcat和jdk/","text":"linux安装Tomcat和jdk步骤 下载tomcat和jdk。 把下载好的压缩包通过xftp5上传到linux服务器。 通过命令解压 1tar -zxvf 文件名 然后将解压的jdk文件夹移动到usr/local文件夹下 1mv + 文件名 + /usr/local 解压Tomcat,将Tomcat文件夹重新命名 1mv + 文件名 + 新名称 修改/etc/profile文件 1vim /etc/profile 在文件中最后加入环境配置 123export JAVA_HOME=/usr/local/jdk1.8.0_11export PATH=$JAVA_HOME/bin:$PATHexport CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar 编辑tomcat文件下的server.xml文件 1vim tomcat/conf/server.xml 将其中的端口改成80 在Tomcat的bin文件夹下启动Tomcat 1./startup.sh (注释： ./ 代表当前目录)","tags":[{"name":"linux入门","slug":"linux入门","permalink":"http://yoursite.com/tags/linux入门/"}]},{"title":"设计模式之代理模式","date":"2018-09-02T16:00:00.000Z","path":"2018/09/03/设计模式之代理模式/","text":"设计模式之代理模式概念代理模式给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用。通俗的来讲代理模式就是我们生活中常见的中介。 为什么要用代理模式？ 中介隔离作用：在某些情况下，一个客户类不想或者不能直接引用一个委托对象，而代理类对象可以在客户类和委托对象之间起到中介的作用，其特征是代理类和委托类实现相同的接口。 开闭原则，增加功能：代理类除了是客户类和委托类的中介之外，我们还可以通过给代理类增加额外的功能来扩展委托类的功能，这样做我们只需要修改代理类而不需要再修改委托类，符合代码设计的开闭原则。代理类主要负责为委托类预处理消息、过滤消息、把消息转发给委托类，以及事后对返回结果的处理等。代理类本身并不真正实现服务，而是同过调用委托类的相关方法，来提供特定的服务。真正的业务功能还是由委托类来实现，但是可以在业务功能执行的前后加入一些公共的服务。例如我们想给项目加入缓存、日志这些功能，我们就可以使用代理类来完成，而没必要打开已经封装好的委托类。 实现1234567891011121314151617181920212223242526272829303132333435363738394041424344public class NetworkTest &#123; public static void main(String[] args) &#123; Server server = new Server(); ProxyServer proxyServer = new ProxyServer(server); proxyServer.browse(); /**输出 * 访问之前的检验 * 真实的服务器访问网络 */ &#125;&#125;interface Network&#123; public void browse();&#125;//被代理类class Server implements Network&#123; public void browse() &#123; System.out.println(\"真实的服务器访问网络\"); &#125;&#125;//代理类class ProxyServer implements Network&#123; private Network network; public ProxyServer(Network network)&#123; this.network = network; &#125; public void check()&#123; System.out.println(\"访问之前的检验\"); &#125; public void browse() &#123; check(); network.browse(); &#125;&#125;","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]},{"title":"设计模式之单例模式","date":"2018-09-01T16:00:00.000Z","path":"2018/09/02/设计模式之单例模式/","text":"单例模式饿汉式12345678910111213141516171819202122public class SingletonTest &#123; public static void main(String[] args) &#123; St instance = St.getInstance(); St in = St.getInstance(); System.out.println(instance == in );//true &#125;&#125;class St&#123; //构造函数私有化 private St()&#123; &#125; private static St St = new St(); public static St getInstance()&#123; return St; &#125;&#125; 懒汉式12345678910111213141516171819202122232425public class SingletonTest2 &#123; public static void main(String[] args) &#123; St instance = St.getInstance(); St in = St.getInstance(); System.out.println(instance == in ); &#125;&#125;class St2&#123; //构造函数私有化 private St2()&#123; &#125; private static St2 St2 = null; public static St2 getInstance()&#123; if(St2==null)&#123; St2 = new St2(); &#125; return St2; &#125;&#125;","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]},{"title":"排序算法之快速排序","date":"2018-07-31T16:00:00.000Z","path":"2018/08/01/排序算法之快速排序/","text":"排序算法之快速排序实现方式 实现原理 快速排序 通过一趟排序将待排序记录分割成独立的两部分，其中一部分记录的关键字均比另一部分关键字小， 则分别对这两部分继续进行排序，直到整个序列有序。 代码实现1234567891011121314151617181920212223242526272829public class KuaiSuSort &#123; public static void main(String[] args) &#123; int array [] = &#123;5,2,4,3,1,9&#125;; kuaiSu(array,0,array.length-1); System.out.println(Arrays.toString(array)); &#125; public static void kuaiSu(int array[],int start ,int end)&#123; if(start&lt;end)&#123; int tmp = array[start]; int low = start; int high =end; while (low&lt;high)&#123; while (low&lt;high&amp;&amp;tmp&lt;=array[high])&#123; high--; &#125; array[low] =array[high]; while (low&lt;high&amp;&amp;tmp&gt;=array[low])&#123; low++; &#125; array[high] = array[low]; &#125; array[low] = tmp; kuaiSu(array,start,low); kuaiSu(array,low+1,end); &#125; &#125;&#125;","tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"排序算法之冒泡排序","date":"2018-07-31T16:00:00.000Z","path":"2018/08/01/排序算法之冒泡排序/","text":"排序算法之冒泡排序实现方式 实现方式 冒泡排序 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 代码实现1234567891011121314151617181920public class MaoPaoSort &#123; public static void main(String[] args) &#123; int arr[] = &#123;1,6,3,21,8,9,3,63,2,6&#125;; maoPao(arr); System.out.println(Arrays.toString(arr)); &#125; public static void maoPao(int arr[])&#123; for (int i = 0; i &lt; arr.length-1; i++) &#123; for (int j =0;j&lt;arr.length-1-i;j++)&#123; if(arr[j]&gt;arr[j+1])&#123; int tmp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = tmp; &#125; &#125; &#125; &#125;&#125;","tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"排序算法之希尔排序","date":"2018-07-31T16:00:00.000Z","path":"2018/08/01/排序算法之希尔排序/","text":"排序算法之希尔排序实现方式 代码实现12345678910111213141516171819202122public class ShellSort &#123; public static void main(String[] args) &#123; int arr[] = &#123;2,6,2,6,4,3,7,9,53,2,6,1,2,&#125;; shell(arr); System.out.println(Arrays.toString(arr)); &#125; public static void shell(int arr[])&#123; for(int i=arr.length/2;i&gt;0;i/=2)&#123; for(int j = i;j&lt;arr.length;j++)&#123; for(int x = j-i;x&gt;=0;x-=i)&#123; if(arr[x]&gt;arr[x+i])&#123; int tmp =arr[x]; arr[x] = arr[x+i]; arr[x+i] = tmp; &#125; &#125; &#125; &#125; &#125;&#125;","tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"idea配置","date":"2018-07-31T16:00:00.000Z","path":"2018/08/01/idea配置/","text":"idea配置进入设置界面： 目录结构如下： Appearance &amp; Behavior设置主题 这里默认提供了三套主题：IntelliJ，Darcula，Windows。这里可以根据自己的喜好进行选择。 设置窗体及菜单的字体及字体大小 如果想要更多的主题效果的话，可以到如下的网站下载：http://www.riaway.com/ 下载以后，导入主题：（方式一）file–&gt; import setttings–&gt;选中下载的主题 jar文件–&gt;一路确认–&gt;重启。重启以后，新主题会自动启用。如果没有启用，可以如下方式选择： 补充:通过插件(plugins)更换主题 Editor - General设置鼠标滚轮修改字体大小(可忽略) 我们可以勾选此设置后，增加 Ctrl +鼠标滚轮快捷键来控制代码字体大小显示 设置鼠标悬浮提示 设置自动导包功能 Add unambiguous imports on the fly：自动导入不明确的结构Optimize imports on the fly：自动帮我们优化导入的包 设置显示行号和方法间的分隔符 如上图红圈所示，可以勾选 Show line numbers：显示行数。我建议一般这个要勾选上。 如上图红圈所示，可以勾选 Show method separators ：显示方法分隔线。这种线有助于我们区分开方法，所以建议勾选上。 忽略大小写提示IntelliJ IDEA的代码提示和补充功能有一个特性：区分大小写。如上图标注所示，默认就是 First letter区分大小写的。区分大小写的情况是这样的：比如我们在 Java代码文件中输入 stringBuffer，IntelliJ IDEA默认是不会帮我们提示或是代码补充的，但是如果我们输入StringBuffer就可以进行代码提示和补充。如果想不区分大小写的话，改为 None选项即可。 设置取消单行显示 tabs的操作如上图标注所示，在打开很多文件的时候，IntelliJ IDEA默认是把所有打开的文件名 Tab单行显示的。但是我个人现在的习惯是使用多行，多行效率比单行高，因为单行会隐藏超过界面部分 Tab，这样找文件不方便。 Editor – Font设置默认的字体、字体大小、字体行间距 Editor – Color Scheme修改当前主题的字体、字体大小、字体行间距(可忽略)如果当前主题不希望使用默认字体、字体大小、字体行间距，还可以单独设置： 修改当前主题的控制台输出的字体及字体大小(可忽略) 修改代码中注释的字体颜色 Doc Comment – Text：修改文档注释的字体颜色Block comment：修改多行注释的字体颜色Line comment：修改当行注释的字体颜色 Editor – Code Style设置超过指定 import个数，改为* (可忽略) Editor – File and Code Templates修改类头的文档注释信息 常用的预设的变量，这里直接贴出官网给的：${PACKAGE_NAME} - the name of the target package where the new class or interface will be created.${PROJECT_NAME} - the name of the current project.${FILE_NAME} - the name of the PHP file that will be created.${NAME} - the name of the new file which you specify in the New File dialog box during the file creation.${USER} - the login name of the current user.${DATE} - the current system date.${TIME} - the current system time.${YEAR} - the current year.${MONTH} - the current month.${DAY} - the current day of the month.${HOUR} - the current hour.${MINUTE} - the current minute.${PRODUCT_NAME} - the name of the IDE in which the file will be created.${MONTH_NAME_SHORT} - the first 3 letters of the month name. Example: Jan, Feb, etc.${MONTH_NAME_FULL} - full name of a month. Example: January, February, etc. Editor – File Encodings设置项目文件编码 说明：Transparent native-to-ascii conversion主要用于转换 ascii，一般都要勾选，不然 Properties文件中的注释显示的都不会是中文 设置当前源文件的编码(可忽略) 对单独文件的编码修改还可以点击右下角的编码设置区。如果代码内容中包含中文，则会弹出如上的操作选择。其中： ①Reload表示使用新编码重新加载，新编码不会保存到文件中，重新打开此文件，旧编码是什么依旧还是什么。②Convert表示使用新编码进行转换，新编码会保存到文件中，重新打开此文件，新编码是什么则是什么。③含有中文的代码文件，Convert之后可能会使中文变成乱码，所以在转换成请做好备份，不然可能出现转换过程变成乱码，无法还原。 Build,Execution,Deployment设置自动编译构建就是以我们编写的 java代码、框架配置文件、国际化等其他资源文件、JSP页面和图片等资源作为“原材料”，去“生产”出一个可以运行的项目的过程。 Intellij Idea默认状态为不自动编译状态，Eclipse默认为自动编译：设置为省电模式 (可忽略)如上图所示， IntelliJ IDEA有一种叫做省电模式的状态，开启这种模式之后IntelliJ IDEA会关掉代码检查和代码提示等功能。所以一般也可认为这是一种阅读模式，如果你在开发过程中遇到突然代码文件不能进行检查和提示，可以来看看这里是否有开启该功能。 设置代码水平或垂直显示","tags":[{"name":"idea","slug":"idea","permalink":"http://yoursite.com/tags/idea/"}]},{"title":"排序算法之插入排序","date":"2018-07-31T16:00:00.000Z","path":"2018/08/01/排序算法之插入排序/","text":"排序算法之插入排序实现方式 代码实现123456789101112131415161718192021public class ChaRuSort &#123; public static void main(String[] args) &#123; int arrays[] =&#123;3,5,6,8,3,6,43,1,3,7,4,9&#125;; chaRu(arrays); System.out.println(Arrays.toString(arrays)); &#125; public static void chaRu(int arr[])&#123; for(int i =1;i&lt;arr.length;i++)&#123; if(arr[i]&lt;arr[i-1])&#123; int tmp = arr[i]; int j; for(j=i-1;j&gt;=0&amp;&amp;tmp&lt;arr[j];j--)&#123; arr[j+1] =arr[j]; &#125; arr[j+1] = tmp; &#125; &#125; &#125;&#125;","tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"类加载器","date":"2018-07-14T16:00:00.000Z","path":"2018/07/15/类加载器/","text":"类加载器所有的类都由类加载器加载，加载的作用就是将 .class文件加载到内存。 类加载器总结JVM 中内置了三个重要的 ClassLoader，除了 BootstrapClassLoader 其他类加载器均由 Java 实现且全部继承自java.lang.ClassLoader： BootstrapClassLoader(启动类加载器) ：最顶层的加载类，由C++实现，负责加载 %JAVA_HOME%/lib目录下的jar包和类或者或被 -Xbootclasspath参数指定的路径中的所有类。 ExtensionClassLoader(扩展类加载器) ：主要负责加载目录 %JRE_HOME%/lib/ext 目录下的jar包和类，或被 java.ext.dirs 系统变量所指定的路径下的jar包。 AppClassLoader(应用程序类加载器) :面向我们用户的加载器，负责加载当前应用classpath下的所有jar包和类。 双亲委派模型双亲委派模型介绍每一个类都有一个对应它的类加载器。系统中的 ClassLoder 在协同工作的时候会默认使用 双亲委派模型 。即在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载。加载的时候，首先会把该请求委派该父类加载器的 loadClass() 处理，因此所有的请求最终都应该传送到顶层的启动类加载器 BootstrapClassLoader 中。当父类加载器无法处理时，才由自己来处理。当父类加载器为null时，会使用启动类加载器 BootstrapClassLoader 作为父类加载器。 双亲委派模型的好处双亲委派模型保证了Java程序的稳定运行，可以避免类的重复加载（JVM 区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类），也保证了 Java 的核心 API 不被篡改。如果没有使用双亲委派模型，而是每个类加载器加载自己的话就会出现一些问题，比如我们编写一个称为 java.lang.Object 类的话，那么程序运行的时候，系统就会出现多个不同的 Object 类。 如果我们不想用双亲委派模型怎么办？为了避免双亲委托机制，我们可以自己定义一个类加载器，然后重载 loadClass() 即可。 自定义类加载器除了 BootstrapClassLoader 其他类加载器均由 Java 实现且全部继承自java.lang.ClassLoader。如果我们要自定义自己的类加载器，很明显需要继承 ClassLoader。","tags":[{"name":"jvm","slug":"jvm","permalink":"http://yoursite.com/tags/jvm/"}]},{"title":"类加载过程","date":"2018-07-14T16:00:00.000Z","path":"2018/07/15/类加载过程/","text":"类加载过程Class 文件需要加载到虚拟机中之后才能运行和使用，那么虚拟机是如何加载这些 Class 文件呢？ 系统加载 Class 类型的文件主要三步:加载-&gt;连接-&gt;初始化。连接过程又可分为三步:验证-&gt;准备-&gt;解析。 加载类加载过程的第一步，主要完成下面3件事情： 通过全类名获取定义此类的二进制字节流 将字节流所代表的静态存储结构转换为方法区的运行时数据结构 在内存中生成一个代表该类的 Class 对象,作为方法区这些数据的访问入口 虚拟机规范多上面这3点并不具体，因此是非常灵活的。比如：”通过全类名获取定义此类的二进制字节流” 并没有指明具体从哪里获取、怎样获取。比如：比较常见的就是从 ZIP 包中读取（日后出现的JAR、EAR、WAR格式的基础）、其他文件生成（典型应用就是JSP）等等。 一个非数组类的加载阶段（加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，这一步我们可以去完成还可以自定义类加载器去控制字节流的获取方式（重写一个类加载器的 loadClass() 方法）。数组类型不通过类加载器创建，它由 Java 虚拟机直接创建。 类加载器、双亲委派模型也是非常重要的知识点，这部分内容会在后面的文章中单独介绍到。 加载阶段和连接阶段的部分内容是交叉进行的，加载阶段尚未结束，连接阶段可能就已经开始了。 验证 准备准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意： 这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在 Java 堆中。 这里所设置的初始值”通常情况”下是数据类型默认的零值（如0、0L、null、false等），比如我们定义了public static int value=111 ，那么 value 变量在准备阶段的初始值就是 0 而不是111（初始化阶段才会复制）。特殊情况：比如给 value 变量加上了 fianl 关键字public static final int value=111 ，那么准备阶段 value 的值就被复制为 111。 解析解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符7类符号引用进行。 符号引用就是一组符号来描述目标，可以是任何字面量。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。在程序实际运行时，只有符号引用是不够的，举个例子：在程序执行方法时，系统需要明确知道这个方法所在的位置。Java 虚拟机为每个类都准备了一张方法表来存放类中所有的方法。当需要调用一个类的方法的时候，只要知道这个方法在方发表中的偏移量就可以直接调用该方法了。通过解析操作符号引用就可以直接转变为目标方法在类中方法表的位置，从而使得方法可以被调用。 综上，解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，也就是得到类或者字段、方法在内存中的指针或者偏移量。 初始化初始化是类加载的最后一步，也是真正执行类中定义的 Java 程序代码(字节码)，初始化阶段是执行类构造器 &lt;clinit&gt; ()方法的过程。 对于&lt;clinit&gt;（） 方法的调用，虚拟机会自己确保其在多线程环境中的安全性。因为 &lt;clinit&gt;（） 方法是带锁线程安全，所以在多线程环境下进行类初始化的话可能会引起死锁，并且这种死锁很难被发现。 对于初始化阶段，虚拟机严格规范了有且只有5中情况下，必须对类进行初始化： 当遇到 new 、 getstatic、putstatic或invokestatic 这4条直接码指令时，比如 new 一个类，读取一个静态字段(未被 final 修饰)、或调用一个类的静态方法时。 使用 java.lang.reflect 包的方法对类进行反射调用时 ，如果类没初始化，需要触发其初始化。 初始化一个类，如果其父类还未初始化，则先触发该父类的初始化。 当虚拟机启动时，用户需要定义一个要执行的主类 (包含 main 方法的那个类)，虚拟机会先初始化这个类。 当使用 JDK1.7 的动态动态语言时，如果一个 MethodHandle 实例的最后解析结构为 REF_getStatic、REF_putStatic、REF_invokeStatic、的方法句柄，并且这个句柄没有初始化，则需要先触发器初始化。","tags":[{"name":"jvm","slug":"jvm","permalink":"http://yoursite.com/tags/jvm/"}]},{"title":"计算机网络","date":"2018-07-14T16:00:00.000Z","path":"2018/07/15/计算机网络/","text":"应用层 域名系统DNS，支持万维网应用的 HTTP协议，支持电子邮件的 SMTP协议 传输层 传输控制协议 TCP， 用户数据协议 UDP 网络层 IP 协议 数据链路层 物理层 应用层 通过应用进程间的交互来完成特定网络应用， 应用层交互的数据单元称为报文。 传输层 负责向两台主机进程之间的通信提供通用的数据传输服务 网络层 选择合适的网间路由和交换结点， 确保数据及时传送。， 在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。 数据链路层 网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。 物理层 实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。 ##三次握手 客户端–发送带有 SYN 标志的数据包–一次握手–服务端服务端–发送带有 SYN/ACK 标志的数据包–二次握手–客户端客户端–发送带有带有 ACK 标志的数据包–三次握手–服务端 为什么要三次握手三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。 第一次握手：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常 第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常 第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常 所以三次握手就能确认双发收发功能都正常，缺一不可。 传了 SYN,为啥还要传 ACK双方通信无误必须是两者互相发送信息都无误。传了 SYN，证明发送方到接收方的通道没有问题，但是接收方到发送方的通道还需要 ACK 信号来进行验证。 为什么要四次挥手任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。 TCP,UDP 协议的区别UDP 在传送数据之前不需要先建立连接，远地主机在收到 UDP 报文后，不需要给出任何确认。虽然 UDP 不提供可靠交付，但在某些情况下 UDP 确是一种最有效的工作方式（一般用于即时通信），比如： QQ 语音、 QQ 视频 、直播等等 TCP 提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。 TCP 不提供广播或多播服务。由于 TCP 要提供可靠的，面向连接的传输服务（TCP的可靠体现在TCP在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源），这一难以避免增加了许多开销，如确认，流量控制，计时器以及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。TCP 一般用于文件传输、发送和接收邮件、远程登录等场景。 TCP 协议如何保证可靠传输 应用数据被分割成 TCP 认为最适合发送的数据块。 TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。 校验和： TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。 TCP 的接收端会丢弃重复的数据。 流量控制： TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制） 拥塞控制： 当网络拥塞时，减少数据的发送。 ARQ协议（Automatic Repeat-reQuest，ARQ）自动重传请求： 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。 超时重传： 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。","tags":[{"name":"协议","slug":"协议","permalink":"http://yoursite.com/tags/协议/"}]},{"title":"hashmap的扩容机制-relize()","date":"2018-07-01T16:00:00.000Z","path":"2018/07/02/hashmap的扩容机制-relize()/","text":"hashmap的扩容机制-relize()12345678910111213void resize(int newCapacity) &#123; //传入新的容量 Entry[] oldTable = table; //引用扩容前的Entry数组 int oldCapacity = oldTable.length; if (oldCapacity == MAXIMUM_CAPACITY) &#123; //扩容前的数组大小如果已经达到最大(2^30)了 threshold = Integer.MAX_VALUE; //修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了 return; &#125; Entry[] newTable = new Entry[newCapacity]; //初始化一个新的Entry数组 transfer(newTable); //！！将数据转移到新的Entry数组里 table = newTable; //HashMap的table属性引用新的Entry数组 threshold = (int) (newCapacity * loadFactor);//修改阈值&#125; 这里就是使用一个容量更大的数组来代替已有的容量小的数组，transfer()方法将原有Entry数组的元素拷贝到新的Entry数组里。 1234567891011121314151617void transfer(Entry[] newTable) &#123; Entry[] src = table; //src引用了旧的Entry数组 int newCapacity = newTable.length; for (int j = 0; j &lt; src.length; j++) &#123; //遍历旧的Entry数组 Entry&lt;K, V&gt; e = src[j]; //取得旧Entry数组的每个元素 if (e != null) &#123; src[j] = null;//释放旧Entry数组的对象引用（for循环后，旧的Entry数组不再引用任何对象） do &#123; Entry&lt;K, V&gt; next = e.next; int i = indexFor(e.hash, newCapacity); //！！重新计算每个元素在数组中的位置 e.next = newTable[i]; //标记[1] newTable[i] = e; //将元素放在数组上 e = next; //访问下一个Entry链上的元素 &#125; while (e != null); &#125; &#125;&#125;","tags":[{"name":"java基础","slug":"java基础","permalink":"http://yoursite.com/tags/java基础/"}]},{"title":"垃圾回收器","date":"2018-06-12T16:00:00.000Z","path":"2018/06/13/垃圾回收器/","text":"垃圾收集器Serial收集器新生代采用复制算法，老年代采用标记-整理算法 它简单而高效（与其他收集器的单线程相比）。 Serial Old 收集器Serial 收集器的老年代版本，它同样是一个单线程收集器。它主要有两大用途：一种用途是在 JDK1.5 以及以前的版本中与 Parallel Scavenge 收集器搭配使用，另一种用途是作为 CMS 收集器的后备方案。 ParNew 收集器ParNew 收集器其实就是 Serial 收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和 Serial 收集器完全一样。 新生代采用复制算法，老年代采用标记-整理算法。 它是许多运行在 Server 模式下的虚拟机的首要选择，除了 Serial 收集器外，只有它能与 CMS 收集器（真正意义上的并发收集器，后面会介绍到）配合工作。 并行和并发概念补充： 并行（Parallel） ：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。 并发（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行，可能会交替执行），用户程序在继续运行，而垃圾收集器运行在另一个 CPU 上。 Parallel Scavenge 收集器Parallel Scavenge 收集器关注点是吞吐量（高效率的利用 CPU）。CMS 等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。所谓吞吐量就是 CPU 中用于运行用户代码的时间与 CPU 总消耗时间的比值。 新生代采用复制算法，老年代采用标记-整理算法。 Parallel Old 收集器Parallel Scavenge 收集器的老年代版本。使用多线程和“标记-整理”算法。在注重吞吐量以及 CPU 资源的场合，都可以优先考虑 Parallel Scavenge 收集器和 Parallel Old 收集器。 CMS 收集器CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用。 CMS（Concurrent Mark Sweep）收集器是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。 从名字中的Mark Sweep这两个词可以看出，CMS 收集器是一种 “标记-清除”算法实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤： 初始标记： 暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 ；并发标记： 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。重新标记： 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短并发清除： 开启用户线程，同时 GC 线程开始对为标记的区域做清扫。 从它的名字就可以看出它是一款优秀的垃圾收集器，主要优点：并发收集、低停顿。但是它有下面三个明显的缺点： 对 CPU 资源敏感；无法处理浮动垃圾；它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。 G1 收集器G1 (Garbage-First) 是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征. 被视为 JDK1.7 中 HotSpot 虚拟机的一个重要进化特征。它具备一下特点： 并行与并发：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。 分代收集：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。 空间整合：与 CMS 的“标记–清理”算法不同，G1 从整体来看是基于“标记整理”算法实现的收集器；从局部上来看是基于“复制”算法实现的。 可预测的停顿：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内。 G1 收集器的运作大致分为以下几个步骤： 初始标记 并发标记 最终标记 筛选回收 G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来)。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 GF 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。","tags":[{"name":"垃圾回收器","slug":"垃圾回收器","permalink":"http://yoursite.com/tags/垃圾回收器/"}]}]
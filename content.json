[{"title":"linux安装Tomcat和jdk","date":"2018-09-09T16:00:00.000Z","path":"2018/09/10/linux安装Tomcat和jdk/","text":"linux安装Tomcat和jdk步骤 下载tomcat和jdk。 把下载好的压缩包通过xftp5上传到linux服务器。 通过命令解压 1tar -zxvf 文件名 然后将解压的jdk文件夹移动到usr/local文件夹下 1mv + 文件名 + /usr/local 解压Tomcat,将Tomcat文件夹重新命名 1mv + 文件名 + 新名称 修改/etc/profile文件 1vim /etc/profile 在文件中最后加入环境配置 123export JAVA_HOME=/usr/local/jdk1.8.0_11export PATH=$JAVA_HOME/bin:$PATHexport CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar 编辑tomcat文件下的server.xml文件 1vim tomcat/conf/server.xml 将其中的端口改成80 在Tomcat的bin文件夹下启动Tomcat 1./startup.sh (注释： ./ 代表当前目录)","tags":[{"name":"linux入门","slug":"linux入门","permalink":"http://yoursite.com/tags/linux入门/"}]},{"title":"设计模式之代理模式","date":"2018-09-02T16:00:00.000Z","path":"2018/09/03/设计模式之代理模式/","text":"设计模式之代理模式概念代理模式给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用。通俗的来讲代理模式就是我们生活中常见的中介。 为什么要用代理模式？ 中介隔离作用：在某些情况下，一个客户类不想或者不能直接引用一个委托对象，而代理类对象可以在客户类和委托对象之间起到中介的作用，其特征是代理类和委托类实现相同的接口。 开闭原则，增加功能：代理类除了是客户类和委托类的中介之外，我们还可以通过给代理类增加额外的功能来扩展委托类的功能，这样做我们只需要修改代理类而不需要再修改委托类，符合代码设计的开闭原则。代理类主要负责为委托类预处理消息、过滤消息、把消息转发给委托类，以及事后对返回结果的处理等。代理类本身并不真正实现服务，而是同过调用委托类的相关方法，来提供特定的服务。真正的业务功能还是由委托类来实现，但是可以在业务功能执行的前后加入一些公共的服务。例如我们想给项目加入缓存、日志这些功能，我们就可以使用代理类来完成，而没必要打开已经封装好的委托类。 实现1234567891011121314151617181920212223242526272829303132333435363738394041424344public class NetworkTest &#123; public static void main(String[] args) &#123; Server server = new Server(); ProxyServer proxyServer = new ProxyServer(server); proxyServer.browse(); /**输出 * 访问之前的检验 * 真实的服务器访问网络 */ &#125;&#125;interface Network&#123; public void browse();&#125;//被代理类class Server implements Network&#123; public void browse() &#123; System.out.println(\"真实的服务器访问网络\"); &#125;&#125;//代理类class ProxyServer implements Network&#123; private Network network; public ProxyServer(Network network)&#123; this.network = network; &#125; public void check()&#123; System.out.println(\"访问之前的检验\"); &#125; public void browse() &#123; check(); network.browse(); &#125;&#125;","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]},{"title":"设计模式之单例模式","date":"2018-09-01T16:00:00.000Z","path":"2018/09/02/设计模式之单例模式/","text":"单例模式饿汉式12345678910111213141516171819202122public class SingletonTest &#123; public static void main(String[] args) &#123; St instance = St.getInstance(); St in = St.getInstance(); System.out.println(instance == in );//true &#125;&#125;class St&#123; //构造函数私有化 private St()&#123; &#125; private static St St = new St(); public static St getInstance()&#123; return St; &#125;&#125; 懒汉式12345678910111213141516171819202122232425public class SingletonTest2 &#123; public static void main(String[] args) &#123; St instance = St.getInstance(); St in = St.getInstance(); System.out.println(instance == in ); &#125;&#125;class St2&#123; //构造函数私有化 private St2()&#123; &#125; private static St2 St2 = null; public static St2 getInstance()&#123; if(St2==null)&#123; St2 = new St2(); &#125; return St2; &#125;&#125;","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]},{"title":"Hello World","date":"2017-08-20T01:54:00.000Z","path":"2017/08/20/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]
[{"title":"linux安装Tomcat和jdk","date":"2018-09-09T16:00:00.000Z","path":"2018/09/10/linux安装Tomcat和jdk/","text":"linux安装Tomcat和jdk步骤 下载tomcat和jdk。 把下载好的压缩包通过xftp5上传到linux服务器。 通过命令解压 1tar -zxvf 文件名 然后将解压的jdk文件夹移动到usr/local文件夹下 1mv + 文件名 + /usr/local 解压Tomcat,将Tomcat文件夹重新命名 1mv + 文件名 + 新名称 修改/etc/profile文件 1vim /etc/profile 在文件中最后加入环境配置 123export JAVA_HOME=/usr/local/jdk1.8.0_11export PATH=$JAVA_HOME/bin:$PATHexport CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar 编辑tomcat文件下的server.xml文件 1vim tomcat/conf/server.xml 将其中的端口改成80 在Tomcat的bin文件夹下启动Tomcat 1./startup.sh (注释： ./ 代表当前目录)","tags":[{"name":"linux入门","slug":"linux入门","permalink":"http://yoursite.com/tags/linux入门/"}]},{"title":"设计模式之代理模式","date":"2018-09-02T16:00:00.000Z","path":"2018/09/03/设计模式之代理模式/","text":"设计模式之代理模式概念代理模式给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用。通俗的来讲代理模式就是我们生活中常见的中介。 为什么要用代理模式？ 中介隔离作用：在某些情况下，一个客户类不想或者不能直接引用一个委托对象，而代理类对象可以在客户类和委托对象之间起到中介的作用，其特征是代理类和委托类实现相同的接口。 开闭原则，增加功能：代理类除了是客户类和委托类的中介之外，我们还可以通过给代理类增加额外的功能来扩展委托类的功能，这样做我们只需要修改代理类而不需要再修改委托类，符合代码设计的开闭原则。代理类主要负责为委托类预处理消息、过滤消息、把消息转发给委托类，以及事后对返回结果的处理等。代理类本身并不真正实现服务，而是同过调用委托类的相关方法，来提供特定的服务。真正的业务功能还是由委托类来实现，但是可以在业务功能执行的前后加入一些公共的服务。例如我们想给项目加入缓存、日志这些功能，我们就可以使用代理类来完成，而没必要打开已经封装好的委托类。 实现1234567891011121314151617181920212223242526272829303132333435363738394041424344public class NetworkTest &#123; public static void main(String[] args) &#123; Server server = new Server(); ProxyServer proxyServer = new ProxyServer(server); proxyServer.browse(); /**输出 * 访问之前的检验 * 真实的服务器访问网络 */ &#125;&#125;interface Network&#123; public void browse();&#125;//被代理类class Server implements Network&#123; public void browse() &#123; System.out.println(\"真实的服务器访问网络\"); &#125;&#125;//代理类class ProxyServer implements Network&#123; private Network network; public ProxyServer(Network network)&#123; this.network = network; &#125; public void check()&#123; System.out.println(\"访问之前的检验\"); &#125; public void browse() &#123; check(); network.browse(); &#125;&#125;","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]},{"title":"设计模式之单例模式","date":"2018-09-01T16:00:00.000Z","path":"2018/09/02/设计模式之单例模式/","text":"单例模式饿汉式12345678910111213141516171819202122public class SingletonTest &#123; public static void main(String[] args) &#123; St instance = St.getInstance(); St in = St.getInstance(); System.out.println(instance == in );//true &#125;&#125;class St&#123; //构造函数私有化 private St()&#123; &#125; private static St St = new St(); public static St getInstance()&#123; return St; &#125;&#125; 懒汉式12345678910111213141516171819202122232425public class SingletonTest2 &#123; public static void main(String[] args) &#123; St instance = St.getInstance(); St in = St.getInstance(); System.out.println(instance == in ); &#125;&#125;class St2&#123; //构造函数私有化 private St2()&#123; &#125; private static St2 St2 = null; public static St2 getInstance()&#123; if(St2==null)&#123; St2 = new St2(); &#125; return St2; &#125;&#125;","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]},{"title":"排序算法之冒泡排序","date":"2018-07-31T16:00:00.000Z","path":"2018/08/01/排序算法之冒泡排序/","text":"排序算法之冒泡排序实现方式 实现方式 冒泡排序 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 代码实现1234567891011121314151617181920public class MaoPaoSort &#123; public static void main(String[] args) &#123; int arr[] = &#123;1,6,3,21,8,9,3,63,2,6&#125;; maoPao(arr); System.out.println(Arrays.toString(arr)); &#125; public static void maoPao(int arr[])&#123; for (int i = 0; i &lt; arr.length-1; i++) &#123; for (int j =0;j&lt;arr.length-1-i;j++)&#123; if(arr[j]&gt;arr[j+1])&#123; int tmp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = tmp; &#125; &#125; &#125; &#125;&#125;","tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"排序算法之希尔排序","date":"2018-07-31T16:00:00.000Z","path":"2018/08/01/排序算法之希尔排序/","text":"排序算法之希尔排序实现方式 代码实现12345678910111213141516171819202122public class ShellSort &#123; public static void main(String[] args) &#123; int arr[] = &#123;2,6,2,6,4,3,7,9,53,2,6,1,2,&#125;; shell(arr); System.out.println(Arrays.toString(arr)); &#125; public static void shell(int arr[])&#123; for(int i=arr.length/2;i&gt;0;i/=2)&#123; for(int j = i;j&lt;arr.length;j++)&#123; for(int x = j-i;x&gt;=0;x-=i)&#123; if(arr[x]&gt;arr[x+i])&#123; int tmp =arr[x]; arr[x] = arr[x+i]; arr[x+i] = tmp; &#125; &#125; &#125; &#125; &#125;&#125;","tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"排序算法之快速排序","date":"2018-07-31T16:00:00.000Z","path":"2018/08/01/排序算法之快速排序/","text":"排序算法之快速排序实现方式 实现原理 快速排序 通过一趟排序将待排序记录分割成独立的两部分，其中一部分记录的关键字均比另一部分关键字小， 则分别对这两部分继续进行排序，直到整个序列有序。 代码实现1234567891011121314151617181920212223242526272829public class KuaiSuSort &#123; public static void main(String[] args) &#123; int array [] = &#123;5,2,4,3,1,9&#125;; kuaiSu(array,0,array.length-1); System.out.println(Arrays.toString(array)); &#125; public static void kuaiSu(int array[],int start ,int end)&#123; if(start&lt;end)&#123; int tmp = array[start]; int low = start; int high =end; while (low&lt;high)&#123; while (low&lt;high&amp;&amp;tmp&lt;=array[high])&#123; high--; &#125; array[low] =array[high]; while (low&lt;high&amp;&amp;tmp&gt;=array[low])&#123; low++; &#125; array[high] = array[low]; &#125; array[low] = tmp; kuaiSu(array,start,low); kuaiSu(array,low+1,end); &#125; &#125;&#125;","tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"排序算法之插入排序","date":"2018-07-31T16:00:00.000Z","path":"2018/08/01/排序算法之插入排序/","text":"排序算法之插入排序实现方式 代码实现123456789101112131415161718192021public class ChaRuSort &#123; public static void main(String[] args) &#123; int arrays[] =&#123;3,5,6,8,3,6,43,1,3,7,4,9&#125;; chaRu(arrays); System.out.println(Arrays.toString(arrays)); &#125; public static void chaRu(int arr[])&#123; for(int i =1;i&lt;arr.length;i++)&#123; if(arr[i]&lt;arr[i-1])&#123; int tmp = arr[i]; int j; for(j=i-1;j&gt;=0&amp;&amp;tmp&lt;arr[j];j--)&#123; arr[j+1] =arr[j]; &#125; arr[j+1] = tmp; &#125; &#125; &#125;&#125;","tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]}]